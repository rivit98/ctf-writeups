import sys

a, b, c = 1, 1, 1000 # set health to big number, because it can be generated by using 'rrrrr' and then 'lr'

labirynth = open("lab.txt").read().splitlines()
labirynth = list(map(str.strip, labirynth))
labirynth = list(filter(len, labirynth))


def splitter(line):
    tok = line.split(':')
    addr = int(tok[0], 16)
    mnem = tok[1].strip()
    return addr, mnem


l = {}
for line in labirynth:
    addr, m = splitter(line)
    l[addr] = m

m = {
    'u': (0, -1),
    'd': (0, 1),
    'r': (1, 0),
    'l': (-1, 0),
}

target_computed = {}
def precompute_target(k, v):
    if "RET" in v:  # just ret, explore further
        return 0
    elif "NOP" in v:  # traverse the code space until something else is found
        return precompute_target(k + 1, l[k + 1])
    elif "kill" in v:  # PUSH3 kill, skip 3 bytes, we failed
        return 4
    elif "0x574" in v:
        # if c == 0: exit
        # dec c
        return 1
    elif "win" in v:
        return 2
    elif "0x57f" in v:
        # inc c
        return 3

precompute_labels = {
    0: "OK",
    1: "DEC C if > 0",
    2: "WIN",
    3: "INC C",
    4: "KILL"
}

opo = {
    'u': 'd',
    'd': 'u',
    'r': 'l',
    'l': 'r',
}

for k, v in l.items():
    target_computed[k] = precompute_target(k, v)


def final_addr(a, b):
    return 0x174 + 4 * (a + 0x10 * b)


def explore(a, b, c, seen, level=0):
    # print(f'a={a} b={b} c={c}')
    # if level > 5: return False
    # if (a,b,c) in seen: return False
    # new_seen = seen | {(a,b,c)}

    for move in 'rudl':
        if seen and opo[move] == seen[-1]: continue
        dx, dy = m[move]
        na = a + dx
        nb = b + dy
        new_pos = (na,nb,c)
        # print(new_pos)

        target_addr = final_addr(na, nb)
        result = target_computed[target_addr]
        print(level, move, precompute_labels[result], hex(target_addr))

        match result:
            case 0:
                explore(na, nb, c, seen + [move], level + 1)
            case 1:
                if c == 0:
                    continue

                explore(na, nb, c - 1, seen + [move], level + 1)
            case 2:
                print("FOUND")
                print(''.join(seen + [move]))
                print(new_pos)
                sys.exit(1)
            case 3:
                explore(na, nb, c + 1, seen + [move], level + 1)
            case 4:
                continue

    return False


if __name__ == '__main__':
    explore(a, b, c, [])
