/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
__int64 sub_55A68FFDE020();
// int mprotect(void *addr, size_t len, int prot);
__int64 __fastcall sub_55A68FFDE036(); // weak
__int64 __fastcall sub_55A68FFDE046(); // weak
// void __noreturn exit(int status);
__int64 __fastcall sub_55A68FFDE056(); // weak
__int64 __fastcall sub_55A68FFDE066(); // weak
__int64 __fastcall sub_55A68FFDE076(); // weak
__int64 __fastcall sub_55A68FFDE086(); // weak
__int64 __fastcall sub_55A68FFDE096(); // weak
// void *dlopen(const char *file, int mode);
__int64 __fastcall sub_55A68FFDE0A6(); // weak
__int64 __fastcall sub_55A68FFDE0B6(); // weak
// void *memfrob(void *s, size_t n);
__int64 __fastcall sub_55A68FFDE0C6(); // weak
__int64 __fastcall sub_55A68FFDE0D6(); // weak
__int64 __fastcall sub_55A68FFDE0E0(_QWORD); // weak
__int64 __fastcall sub_55A68FFDE0E6(); // weak
__int64 __fastcall sub_55A68FFDE0F6(); // weak
__int64 __fastcall sub_55A68FFDE106(); // weak
__int64 __fastcall sub_55A68FFDE116(); // weak
__int64 __fastcall sub_55A68FFDE126(); // weak
__int64 __fastcall sub_55A68FFDE136(); // weak
__int64 __fastcall sub_55A68FFDE146(); // weak
void __fastcall __noreturn start(__int64, __int64, void (*)(void));
void *sub_55A68FFDE180();
__int64 sub_55A68FFDE1B0(void); // weak
void *sub_55A68FFDE1F0();
__int64 sub_55A68FFDE240();
__int64 __fastcall sub_55A68FFDE249(_BYTE *a1);
__int64 __fastcall sub_55A68FFDE27B(); // weak
__int64 __fastcall main(int argc, char **a2, char **a3);
__int64 __fastcall main2(__int64 input, __int64 input);
void term_proc();
// int __fastcall _cxa_finalize(void *);
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

__int64 (*off_55A68FFE1010)(void) = NULL; // weak
void *off_55A68FFE10B0 = &off_55A68FFE10B0; // idb
_UNKNOWN unk_55A68FFE10B8; // weak
char byte_55A68FFE10C0; // weak


//----- (000055A68FFDE000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 55A68FFE1110: using guessed type __int64 _gmon_start__(void);

//----- (000055A68FFDE020) ----------------------------------------------------
__int64 sub_55A68FFDE020()
{
  return off_55A68FFE1010();
}
// 55A68FFE1010: using guessed type __int64 (*off_55A68FFE1010)(void);

//----- (000055A68FFDE036) ----------------------------------------------------
__int64 sub_55A68FFDE036()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE036: using guessed type __int64 __fastcall sub_55A68FFDE036();

//----- (000055A68FFDE046) ----------------------------------------------------
__int64 sub_55A68FFDE046()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE046: using guessed type __int64 __fastcall sub_55A68FFDE046();

//----- (000055A68FFDE056) ----------------------------------------------------
__int64 sub_55A68FFDE056()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE056: using guessed type __int64 __fastcall sub_55A68FFDE056();

//----- (000055A68FFDE066) ----------------------------------------------------
__int64 sub_55A68FFDE066()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE066: using guessed type __int64 __fastcall sub_55A68FFDE066();

//----- (000055A68FFDE076) ----------------------------------------------------
__int64 sub_55A68FFDE076()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE076: using guessed type __int64 __fastcall sub_55A68FFDE076();

//----- (000055A68FFDE086) ----------------------------------------------------
__int64 sub_55A68FFDE086()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE086: using guessed type __int64 __fastcall sub_55A68FFDE086();

//----- (000055A68FFDE096) ----------------------------------------------------
__int64 sub_55A68FFDE096()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE096: using guessed type __int64 __fastcall sub_55A68FFDE096();

//----- (000055A68FFDE0A6) ----------------------------------------------------
__int64 sub_55A68FFDE0A6()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE0A6: using guessed type __int64 __fastcall sub_55A68FFDE0A6();

//----- (000055A68FFDE0B6) ----------------------------------------------------
__int64 sub_55A68FFDE0B6()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE0B6: using guessed type __int64 __fastcall sub_55A68FFDE0B6();

//----- (000055A68FFDE0C6) ----------------------------------------------------
__int64 sub_55A68FFDE0C6()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE0C6: using guessed type __int64 __fastcall sub_55A68FFDE0C6();

//----- (000055A68FFDE0D6) ----------------------------------------------------
__int64 sub_55A68FFDE0D6()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE0D6: using guessed type __int64 __fastcall sub_55A68FFDE0D6();

//----- (000055A68FFDE0E6) ----------------------------------------------------
__int64 sub_55A68FFDE0E6()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE0E6: using guessed type __int64 __fastcall sub_55A68FFDE0E6();

//----- (000055A68FFDE0F6) ----------------------------------------------------
__int64 sub_55A68FFDE0F6()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE0F6: using guessed type __int64 __fastcall sub_55A68FFDE0F6();

//----- (000055A68FFDE106) ----------------------------------------------------
__int64 sub_55A68FFDE106()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE106: using guessed type __int64 __fastcall sub_55A68FFDE106();

//----- (000055A68FFDE116) ----------------------------------------------------
__int64 sub_55A68FFDE116()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE116: using guessed type __int64 __fastcall sub_55A68FFDE116();

//----- (000055A68FFDE126) ----------------------------------------------------
__int64 sub_55A68FFDE126()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE126: using guessed type __int64 __fastcall sub_55A68FFDE126();

//----- (000055A68FFDE136) ----------------------------------------------------
__int64 sub_55A68FFDE136()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE136: using guessed type __int64 __fastcall sub_55A68FFDE136();

//----- (000055A68FFDE146) ----------------------------------------------------
__int64 sub_55A68FFDE146()
{
  return sub_55A68FFDE020();
}
// 55A68FFDE146: using guessed type __int64 __fastcall sub_55A68FFDE146();

//----- (000055A68FFDE150) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 55A68FFDE15A: positive sp value 8 has been found
// 55A68FFDE161: variable 'v3' is possibly undefined

//----- (000055A68FFDE180) ----------------------------------------------------
void *sub_55A68FFDE180()
{
  return &unk_55A68FFE10B8;
}

//----- (000055A68FFDE1B0) ----------------------------------------------------
__int64 sub_55A68FFDE1B0()
{
  return 0LL;
}
// 55A68FFDE1B0: using guessed type __int64 __fastcall sub_55A68FFDE1B0();

//----- (000055A68FFDE1F0) ----------------------------------------------------
void *sub_55A68FFDE1F0()
{
  void *result; // rax

  if ( !byte_55A68FFE10C0 )
  {
    if ( &_cxa_finalize )
      _cxa_finalize(off_55A68FFE10B0);
    result = sub_55A68FFDE180();
    byte_55A68FFE10C0 = 1;
  }
  return result;
}
// 55A68FFE10C0: using guessed type char byte_55A68FFE10C0;

//----- (000055A68FFDE240) ----------------------------------------------------
// attributes: thunk
__int64 sub_55A68FFDE240()
{
  return sub_55A68FFDE1B0();
}
// 55A68FFDE1B0: using guessed type __int64 sub_55A68FFDE1B0(void);

//----- (000055A68FFDE249) ----------------------------------------------------
__int64 __fastcall sub_55A68FFDE249(_BYTE *a1)
{
  _BYTE *v1; // rax
  _BYTE *v3; // [rsp+10h] [rbp-8h]

  v3 = a1;
  do
    v1 = v3++;
  while ( *v1 );
  return v3 - a1 - 1;
}

//----- (000055A68FFDE27B) ----------------------------------------------------
__int64 sub_55A68FFDE27B()
{
  unsigned __int64 v0; // rdi
  __int64 result; // rax
  unsigned int s; // [rsp+10h] [rbp-50h] BYREF
  int i; // [rsp+14h] [rbp-4Ch]
  int v4; // [rsp+18h] [rbp-48h]
  int v5; // [rsp+1Ch] [rbp-44h]
  __int64 v6; // [rsp+20h] [rbp-40h]
  __int64 v7; // [rsp+28h] [rbp-38h]
  _QWORD *v8; // [rsp+30h] [rbp-30h]
  __int64 v9; // [rsp+38h] [rbp-28h]
  __int64 v10; // [rsp+40h] [rbp-20h]
  size_t n; // [rsp+48h] [rbp-18h]
  _QWORD *v12; // [rsp+50h] [rbp-10h]
  unsigned __int64 v13; // [rsp+58h] [rbp-8h]

  v13 = __readfsqword(0x28u);
  v8 = dlopen(0LL, 1);
  v9 = *(_QWORD *)(v8[31] + 8LL);
  v10 = v8[2];
  v6 = 0LL;
  v7 = 0LL;
  for ( i = 0; i <= 19; ++i )
  {
    v12 = (_QWORD *)(16LL * i + v10);
    if ( *v12 == 6LL )
    {
      v6 = v12[1];
    }
    else if ( *v12 == 5LL )
    {
      v7 = v12[1];
    }
  }
  v4 = 0;
  mprotect((void *)(v6 & 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3);
  while ( *(_QWORD *)(24LL * v4 + v9) )
  {
    s = *(_QWORD *)(24LL * v4 + v9 + 16);
    if ( s )
    {
      v5 = HIDWORD(*(_QWORD *)(24LL * v4 + v9 + 8));
      memfrob(&s, 4uLL);
      *(_DWORD *)(v6 + 24LL * v5) = s;
      n = sub_55A68FFDE249((_BYTE *)(s + v7));
      memfrob((void *)(v7 + s), n);
      *(_QWORD *)(24LL * v4 + v9 + 16) = 0LL;
    }
    ++v4;
  }
  v0 = v6 & 0xFFFFFFFFFFFFF000LL;
  mprotect((void *)(v6 & 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 1);
  result = v13 - __readfsqword(0x28u);
  if ( result )
    return sub_55A68FFDE0E0(v0);
  return result;
}
// 55A68FFDE0E0: using guessed type __int64 __fastcall sub_55A68FFDE0E0(_QWORD);
// 55A68FFDE27B: using guessed type __int64 __fastcall sub_55A68FFDE27B();

//----- (000055A68FFDE4A8) ----------------------------------------------------
__int64 __fastcall main(int argc, char **a2, char **a3)
{
  if ( argc != 2 )
    exit(-1);
  main2((__int64)a2[1], (__int64)a2);
  return 0LL;
}

//----- (000055A68FFDE4E1) ----------------------------------------------------
__int64 __fastcall main2(__int64 input, __int64 a2)
{
  __int64 aes256cbc; // rax
  __int64 result; // rax
  int outl; // [rsp+1Ch] [rbp-894h] BYREF
  int enc_len; // [rsp+20h] [rbp-890h] BYREF
  int i; // [rsp+24h] [rbp-88Ch]
  __int64 ctx; // [rsp+28h] [rbp-888h]
  char *buffer_1; // [rsp+30h] [rbp-880h] BYREF
  int v9; // [rsp+38h] [rbp-878h]
  char *v10; // [rsp+48h] [rbp-868h]
  int v11; // [rsp+50h] [rbp-860h]
  __int64 inl; // [rsp+58h] [rbp-858h]
  __int64 v13; // [rsp+70h] [rbp-840h]
  __int64 v14; // [rsp+78h] [rbp-838h]
  __int64 v15; // [rsp+80h] [rbp-830h]
  char out[1024]; // [rsp+A0h] [rbp-810h] BYREF
  char in[1032]; // [rsp+4A0h] [rbp-410h] BYREF
  unsigned __int64 cookie; // [rsp+8A8h] [rbp-8h]

  cookie = __readfsqword(0x28u);
  memset(out, 0, sizeof(out));
  memset(in, 0, 1024);
  outl = j___strlen_sse2(input);
  j___memmove_avx_unaligned((__int64)out, input, outl);
  for ( i = 0; i <= 19; ++i )
  {
    v13 = 0LL;
    v14 = 0LL;
    v15 = 0LL;
    v9 = outl;
    buffer_1 = out;
    v11 = 1024;
    v10 = in;
    j_deflateInit(&buffer_1, 0xFFFFFFFFLL, "1.2.12", 112LL);
    j_deflate(&buffer_1, 4LL);
    j_deflateEnd(&buffer_1);
    ctx = j_EVP_CIPHER_CTX_new();
    aes256cbc = j_EVP_aes_256_cbc();
    j_EVP_EncryptInit_ex(ctx, aes256cbc, 0LL, &key, &iv);
    j_EVP_EncryptUpdate(ctx, out, &outl, in, (unsigned int)inl);
    j_EVP_EncryptFinal_ex(ctx, &out[outl], &enc_len);
    j_EVP_CIPHER_CTX_free(ctx);
    outl += enc_len;
  }
  if ( (unsigned int)j___memcmp_sse4_1(out, &target, 352LL) )
    puts("Incorrect :msfrog:");
  else
    puts("Correct :msfrogcircle:");
  result = cookie - __readfsqword(0x28u);
  if ( result )
    return sub_55A68FFDE0E0();
  return result;
}
// 55A68FFDE040: using guessed type __int64 __fastcall puts(_QWORD);
// 55A68FFDE060: using guessed type __int64 __fastcall j_deflate(_QWORD, _QWORD);
// 55A68FFDE070: using guessed type __int64 __fastcall j_deflateInit(_QWORD, _QWORD, _QWORD, _QWORD);
// 55A68FFDE090: using guessed type __int64 __fastcall j_deflateEnd(_QWORD);
// 55A68FFDE0B0: using guessed type __int64 j_EVP_CIPHER_CTX_new(void);
// 55A68FFDE0D0: using guessed type __int64 j_EVP_aes_256_cbc(void);
// 55A68FFDE0E0: using guessed type __int64 sub_55A68FFDE0E0(void);
// 55A68FFDE0F0: using guessed type __int64 __fastcall j___memcmp_sse4_1(_QWORD, _QWORD, _QWORD);
// 55A68FFDE100: using guessed type __int64 __fastcall j_EVP_CIPHER_CTX_free(_QWORD);
// 55A68FFDE110: using guessed type __int64 __fastcall j_EVP_EncryptFinal_ex(_QWORD, _QWORD, _QWORD);
// 55A68FFDE130: using guessed type __int64 __fastcall j_EVP_EncryptInit_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 55A68FFDE140: using guessed type __int64 __fastcall j_EVP_EncryptUpdate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (000055A68FFDE79C) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=55 queued=30 decompiled=30 lumina nreq=0 worse=0 better=0
// ALL OK, 30 function(s) have been successfully decompiled
