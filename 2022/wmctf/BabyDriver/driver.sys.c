/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 __fastcall sub_140001000(__int64 patched);
__int64 sub_140001098();
__int64 __fastcall first_weird(__int64 a1, _QWORD *flag_ptr, __int64 a3, __int64 a4);
__int64 __fastcall second_weird(__int64, _QWORD *, __int64, __int64);
__int64 __fastcall flag_transformer(__int64 *a1);
__int64 __fastcall init1(__int64);
__int64 sub_140001230();
char __fastcall sub_140001238(PCSZ flag_str, const char *welcome_str_maybe);
__int64 __fastcall sub_140001284(int a1, unsigned int a2);
__int64 __fastcall sub_140001380(int a1);
__int64 __fastcall sub_1400013CC(_DWORD *, int);
char __fastcall aes(char *plain, int plain_len, char *key);
__int64 __fastcall sub_1400017FC(__int128 *, int);
__int64 __fastcall sub_140001864(_OWORD *a1);
void __fastcall __noreturn kebugcheck(ULONG_PTR BugCheckParameter1); // idb
__int64 __fastcall sub_1400019B0(__int64 a1, __int64 a2);
__m128i *__fastcall sub_140001A40(__m128i *, unsigned __int64, unsigned __int64);
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath);
// void __cdecl _security_init_cookie();

//-------------------------------------------------------------------------
// Data declarations

// extern PVOID (__stdcall *MmGetSystemRoutineAddress)(PUNICODE_STRING SystemRoutineName);
// extern BOOLEAN (__stdcall *MmIsAddressValid)(PVOID VirtualAddress);
// extern void (__stdcall *RtlInitAnsiString)(PANSI_STRING DestinationString, PCSZ SourceString);
// extern void (__stdcall __noreturn *KeBugCheckEx)(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1, ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4);
// extern void (__stdcall *RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
_DWORD sbox[256] =
{
  99,
  124,
  119,
  123,
  242,
  107,
  111,
  197,
  48,
  1,
  103,
  43,
  254,
  215,
  171,
  118,
  202,
  130,
  201,
  125,
  250,
  89,
  71,
  240,
  173,
  212,
  162,
  175,
  156,
  164,
  114,
  192,
  183,
  253,
  147,
  38,
  54,
  63,
  247,
  204,
  52,
  165,
  229,
  241,
  113,
  216,
  49,
  21,
  4,
  199,
  35,
  195,
  24,
  150,
  5,
  154,
  7,
  18,
  128,
  226,
  235,
  39,
  178,
  117,
  9,
  131,
  44,
  26,
  27,
  110,
  90,
  160,
  82,
  59,
  214,
  179,
  41,
  227,
  47,
  132,
  83,
  209,
  0,
  237,
  32,
  252,
  177,
  91,
  106,
  203,
  190,
  57,
  74,
  76,
  88,
  207,
  208,
  239,
  170,
  251,
  67,
  77,
  51,
  133,
  69,
  249,
  2,
  127,
  80,
  60,
  159,
  168,
  81,
  163,
  64,
  143,
  146,
  157,
  56,
  245,
  188,
  182,
  218,
  33,
  16,
  255,
  243,
  210,
  205,
  12,
  19,
  236,
  95,
  151,
  68,
  23,
  196,
  167,
  126,
  61,
  100,
  93,
  25,
  115,
  96,
  129,
  79,
  220,
  34,
  42,
  144,
  136,
  70,
  238,
  184,
  20,
  222,
  94,
  11,
  219,
  224,
  50,
  58,
  10,
  73,
  6,
  36,
  92,
  194,
  211,
  172,
  98,
  145,
  149,
  228,
  121,
  231,
  200,
  55,
  109,
  141,
  213,
  78,
  169,
  108,
  86,
  244,
  234,
  101,
  122,
  174,
  8,
  186,
  120,
  37,
  46,
  28,
  166,
  180,
  198,
  232,
  221,
  116,
  31,
  75,
  189,
  139,
  138,
  112,
  62,
  181,
  102,
  72,
  3,
  246,
  14,
  97,
  53,
  87,
  185,
  134,
  193,
  29,
  158,
  225,
  248,
  152,
  17,
  105,
  217,
  142,
  148,
  155,
  30,
  135,
  233,
  206,
  85,
  40,
  223,
  140,
  161,
  137,
  13,
  191,
  230,
  66,
  104,
  65,
  153,
  45,
  15,
  176,
  84,
  187,
  22
}; // weak
_UNKNOWN unk_140002460; // weak
_UNKNOWN unk_140002498; // weak
__int16 word_1400024D8 = 0; // weak
uintptr_t _security_cookie = 47936899621426ui64;
ULONG_PTR BugCheckParameter3 = 18446696136809930189ui64; // idb
__int64 (__fastcall *original_call)(_QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 (__fastcall *qword_140003018)(_QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 intercepted = 0i64; // weak
__int64 qword_140003028 = 0i64; // weak
_UNKNOWN unk_140003030; // weak


//----- (0000000140001000) ----------------------------------------------------
__int64 __fastcall sub_140001000(__int64 patched)
{
  __int64 (__fastcall *ExRegisterAttributeInformationCallback)(__int64 *); // rax
  __int64 v3; // rbx
  __int64 result; // rax
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-28h] BYREF
  __int64 v6[3]; // [rsp+30h] [rbp-18h] BYREF

  DestinationString = 0i64;
  RtlInitUnicodeString(&DestinationString, L"ExRegisterAttributeInformationCallback");
  ExRegisterAttributeInformationCallback = (__int64 (__fastcall *)(__int64 *))MmGetSystemRoutineAddress(&DestinationString);
  v3 = (__int64)ExRegisterAttributeInformationCallback
     + *((unsigned int *)ExRegisterAttributeInformationCallback + 4)
     + 20;
  original_call = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))v3;
  qword_140003018 = *(__int64 (__fastcall **)(_QWORD, _QWORD, _QWORD, _QWORD))(v3 + 8);
  *(_OWORD *)v3 = 0i64;
  v6[0] = (__int64)first_weird;
  v6[1] = (__int64)second_weird;
  result = ExRegisterAttributeInformationCallback(v6);
  if ( (int)result >= 0 )
  {
    intercepted = patched;
    qword_140003028 = v3;
  }
  return result;
}
// 140003010: using guessed type __int64 (__fastcall *original_call)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140003018: using guessed type __int64 (__fastcall *qword_140003018)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140003020: using guessed type __int64 intercepted;
// 140003028: using guessed type __int64 qword_140003028;

//----- (0000000140001098) ----------------------------------------------------
__int64 sub_140001098()
{
  __int64 result; // rax

  if ( qword_140003028 )
  {
    *(_DWORD *)qword_140003028 = original_call;
    result = (unsigned int)qword_140003018;
    *(_DWORD *)(qword_140003028 + 4) = (_DWORD)qword_140003018;
  }
  return result;
}
// 140003010: using guessed type __int64 qword_140003010;
// 140003018: using guessed type __int64 (__fastcall *qword_140003018)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140003028: using guessed type __int64 qword_140003028;

//----- (00000001400010C0) ----------------------------------------------------
__int64 __fastcall first_weird(__int64 a1, _QWORD *flag_ptr, __int64 a3, __int64 a4)
{
  if ( !MmIsAddressValid(flag_ptr) )
    return 0i64;
  if ( *flag_ptr == 0x123456111i64 )
  {
    ((void (__fastcall *)(_QWORD *))intercepted)(flag_ptr);
    return 0i64;
  }
  if ( !original_call )
    return 0i64;
  return original_call(a1, flag_ptr, a3, a4);
}
// 140003010: using guessed type __int64 (__fastcall *original_call)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140003020: using guessed type __int64 intercepted;

//----- (0000000140001150) ----------------------------------------------------
__int64 __fastcall second_weird(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4)
{
  if ( !MmIsAddressValid(a2) )
    return 0i64;
  if ( *a2 == 0x123456222i64 )
  {
    ((void (__fastcall *)(_QWORD *))intercepted)(a2);
    return 0i64;
  }
  if ( !qword_140003018 )
    return 0i64;
  return qword_140003018(a1, a2, a3, a4);
}
// 140003018: using guessed type __int64 (__fastcall *qword_140003018)(_QWORD, _QWORD, _QWORD, _QWORD);
// 140003020: using guessed type __int64 qword_140003020;

//----- (00000001400011E0) ----------------------------------------------------
__int64 __fastcall flag_transformer(__int64 *a1)
{
  PCSZ *flag; // rcx

  if ( a1[1] == 1 && (flag = (PCSZ *)a1[2]) != 0i64 )
    return sub_140001238(*flag, flag[2]);
  else
    return 0i64;
}

//----- (0000000140001204) ----------------------------------------------------
__int64 __fastcall init1(__int64 a1)
{
  *(_QWORD *)(a1 + 104) = sub_140001230;
  sub_140001000((__int64)flag_transformer);
  return 0i64;
}

//----- (0000000140001238) ----------------------------------------------------
char __fastcall sub_140001238(PCSZ flag_str, const char *welcome_str_maybe)
{
  struct ANSI_STRING v4; // [rsp+20h] [rbp-28h] BYREF
  struct _STRING DestinationString; // [rsp+30h] [rbp-18h] BYREF

  DestinationString = 0i64;
  RtlInitAnsiString(&DestinationString, welcome_str_maybe);
  v4 = 0i64;
  RtlInitAnsiString(&v4, flag_str);
  return aes((unsigned __int8 *)v4.Buffer, v4.Length, (__int64)DestinationString.Buffer);
}

//----- (0000000140001284) ----------------------------------------------------
__int64 __fastcall sub_140001284(int a1, unsigned int a2)
{
  unsigned int v2; // r9d
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  int v6; // edx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // eax
  unsigned int v11; // r9d
  unsigned int v12; // eax
  int v13; // r10d
  unsigned int v15; // [rsp+30h] [rbp+8h]

  v2 = a2;
  if ( a1 == 1 )
    return v2;
  if ( a1 != 2 )
  {
    switch ( a1 )
    {
      case 3:
        v3 = 2 * a2;
        break;
      case 9:
        v4 = 2 * a2;
        if ( ((2 * a2) & 0x100) != 0 )
          v4 = (unsigned __int8)v4 ^ 0x1B;
        v5 = 2 * v4;
        if ( (v5 & 0x100) != 0 )
          v5 = (unsigned __int8)v5 ^ 0x1B;
        v3 = 2 * v5;
        break;
      case 11:
        v6 = 2 * a2;
        v7 = v6;
        if ( (v6 & 0x100) != 0 )
          v7 = (unsigned __int8)v6 ^ 0x1B;
        v8 = 2 * v7;
        if ( (v8 & 0x100) != 0 )
          v8 = (unsigned __int8)v8 ^ 0x1B;
        v9 = 2 * v8;
        if ( (v9 & 0x100) != 0 )
          v9 = (unsigned __int8)v9 ^ 0x1B;
        if ( (v6 & 0x100) != 0 )
          v6 = (unsigned __int8)v6 ^ 0x1B;
        v3 = v6 ^ v9;
LABEL_25:
        v2 ^= v3;
        return v2;
      case 13:
        v10 = sub_140001380(a2);
        return v10 ^ v11;
      case 14:
        v12 = sub_140001380(a2);
        return v13 ^ v12;
      default:
        return v15;
    }
    if ( (v3 & 0x100) != 0 )
      v3 = (unsigned __int8)v3 ^ 0x1B;
    goto LABEL_25;
  }
  v2 = 2 * a2;
  if ( ((2 * a2) & 0x100) != 0 )
    return (unsigned __int8)v2 ^ 0x1Bu;
  return v2;
}
// 140001343: variable 'v11' is possibly undefined
// 14000136B: variable 'v13' is possibly undefined
// 140001380: using guessed type __int64 __fastcall sub_140001380(_QWORD);

//----- (0000000140001380) ----------------------------------------------------
__int64 __fastcall sub_140001380(int a1)
{
  int v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // ecx
  int v5; // ecx
  int v6; // eax

  v2 = 2 * a1;
  v1 = v2;
  v3 = v2 & 0x100;
  if ( (v2 & 0x100) != 0 )
    v2 = (unsigned __int8)v2 ^ 0x1B;
  v4 = 2 * v2;
  if ( (v4 & 0x100) != 0 )
    v4 = (unsigned __int8)v4 ^ 0x1B;
  v5 = 2 * v4;
  if ( (v5 & 0x100) != 0 )
    v5 = (unsigned __int8)v5 ^ 0x1B;
  if ( v3 )
    v1 = (unsigned __int8)v1 ^ 0x1B;
  v6 = 2 * v1;
  if ( (v6 & 0x100) != 0 )
    v6 = (unsigned __int8)v6 ^ 0x1B;
  return v5 ^ (unsigned int)v6;
}

//----- (00000001400013CC) ----------------------------------------------------
__int64 __fastcall sub_1400013CC(_DWORD *a1, int a2)
{
  _DWORD *v2; // r8
  __int64 v3; // r9
  char *v4; // r10
  int v5; // ecx
  _DWORD *v6; // rdx
  int v7; // eax
  __int64 v8; // rcx
  __int64 result; // rax
  int v10[4]; // [rsp+0h] [rbp-28h]

  v2 = a1;
  v3 = 4i64;
  v4 = (char *)&unk_140003030 + 16i64 * a2 - (_QWORD)a1;
  do
  {
    v5 = *(_DWORD *)((char *)v2 + (_QWORD)v4);
    v6 = v2;
    v10[0] = HIBYTE(v5);
    v10[1] = BYTE2(v5);
    v10[2] = BYTE1(v5);
    v7 = (unsigned __int8)v5;
    v8 = 0i64;
    v10[3] = v7;
    do
    {
      result = (unsigned int)v10[v8++];
      *v6 ^= result;
      v6 += 4;
    }
    while ( v8 < 4 );
    ++v2;
    --v3;
  }
  while ( v3 );
  return result;
}

//----- (0000000140001460) ----------------------------------------------------
char __fastcall aes(char *plain, int plain_len, char *key)
{
  _DWORD *v3; // r11
  char *v4; // r9
  signed __int64 v5; // r10
  __int64 v7; // r8
  int v9; // eax
  int v10; // ebx
  int *v11; // rdi
  int v12; // ecx
  __int64 i; // rdx
  int v14; // ecx
  int *v15; // rbx
  int *v16; // rcx
  __int64 v17; // r9
  char *v18; // rdx
  int *v19; // r8
  __int64 v20; // r10
  int v21; // eax
  int *v22; // rdx
  __int64 v23; // r8
  __int64 v24; // r9
  __int64 v25; // r15
  __int64 v26; // r14
  int v27; // r12d
  int v28; // r13d
  char *v29; // rax
  int v30; // r15d
  char *v31; // rsi
  int v32; // edi
  int v33; // eax
  int v34; // r11d
  int v35; // r11d
  char *v36; // rax
  int *v37; // rdx
  __int64 v38; // r8
  __int64 v39; // r9
  int *v40; // rcx
  char *v41; // r11
  __int64 v42; // r9
  int *v43; // rdx
  __int64 v44; // r8
  bool v45; // zf
  int j; // [rsp+28h] [rbp-99h]
  char *v48; // [rsp+40h] [rbp-81h]
  __int64 v49; // [rsp+48h] [rbp-79h]
  __int128 v50; // [rsp+58h] [rbp-69h] BYREF
  int v51[16]; // [rsp+68h] [rbp-59h] BYREF
  __m128i v52[4]; // [rsp+A8h] [rbp-19h] BYREF

  v3 = &unk_140003030;
  v4 = key + 2;
  v5 = &unk_140003030 - (_UNKNOWN *)key;
  v7 = 4i64;
  do
  {
    v9 = (unsigned __int8)v4[1];
    *(_DWORD *)&v4[v5 - 2] = v9 | (((unsigned __int8)*v4 | (((unsigned __int8)*(v4 - 1) | (*(v4 - 2) << 8)) << 8)) << 8);
    v4 += 4;
    --v7;
  }
  while ( v7 );
  v10 = 4;
  v11 = (int *)&unk_140002460;
  do
  {
    if ( (v10 & 3) != 0 )
    {
      v14 = v3[3] ^ *v3;
    }
    else
    {
      v12 = v3[3];
      LODWORD(v50) = HIBYTE(v12);
      DWORD1(v50) = BYTE2(v12);
      DWORD2(v50) = BYTE1(v12);
      HIDWORD(v50) = (unsigned __int8)v12;
      sub_1400017FC(&v50, 1);
      for ( i = 0i64; i < 4; ++i )
        v51[i - 4] = sbox[16 * ((v51[i - 4] >> 4) & 0xF) + (v51[i - 4] & 0xF)];
      v9 = *v11++;
      v14 = *v3 ^ v9 ^ (HIDWORD(v50) | ((DWORD2(v50) | ((DWORD1(v50) | ((_DWORD)v50 << 8)) << 8)) << 8));
    }
    v3[4] = v14;
    ++v10;
    ++v3;
  }
  while ( v10 < 44 );
  if ( plain_len > 0 )
  {
    v48 = plain;
    v15 = (int *)&unk_140002498;
    v49 = ((unsigned int)(plain_len - 1) >> 4) + 1;
    do
    {
      v16 = v51;
      v17 = 4i64;
      do
      {
        v18 = plain;
        v19 = v16;
        plain += 4;
        v20 = 4i64;
        do
        {
          v21 = (unsigned __int8)*v18++;
          *v19 = v21;
          v19 += 4;
          --v20;
        }
        while ( v20 );
        ++v16;
        --v17;
      }
      while ( v17 );
      *(_QWORD *)&v50 = plain;
      sub_1400013CC(v51, 0);
      for ( j = 1; j < 10; ++j )
      {
        v22 = v51;
        v23 = 4i64;
        do
        {
          v24 = 4i64;
          do
          {
            *v22 = sbox[16 * ((*v22 >> 4) & 0xF) + (*v22 & 0xF)];
            ++v22;
            --v24;
          }
          while ( v24 );
          --v23;
        }
        while ( v23 );
        sub_140001864(v51);
        sub_140001A40(v52, (unsigned __int64)v51, 0x40ui64);
        v25 = -96i64 - (_QWORD)&unk_140002498;
        do
        {
          v26 = 0i64;
          v27 = v15[1];
          v28 = *v15;
          v29 = (char *)v15 + v25;
          v30 = *(v15 - 1);
          v31 = v29;
          v32 = *(v15 - 2);
          do
          {
            sub_140001284(v30, v52[1].m128i_u32[v26]);
            sub_140001284(v27, v52[3].m128i_u32[v26]);
            sub_140001284(v32, v52[0].m128i_u32[v26]);
            v33 = sub_140001284(v28, v52[2].m128i_u32[v26]);
            v35 = v33 ^ v34;
            v36 = &v31[4 * v26++];
            *(__int32 *)((char *)v52[2].m128i_i32 + (_QWORD)v36) = v35;
          }
          while ( v26 < 4 );
          v25 = -96i64 - (_QWORD)&unk_140002498;
          v15 += 4;
        }
        while ( (__int64)v15 < (__int64)&word_1400024D8 );
        sub_1400013CC(v51, j);
        v15 = (int *)&unk_140002498;
      }
      plain = (char *)v50;
      v37 = v51;
      v38 = 4i64;
      do
      {
        v39 = 4i64;
        do
        {
          *v37 = sbox[16 * ((*v37 >> 4) & 0xF) + (*v37 & 0xF)];
          ++v37;
          --v39;
        }
        while ( v39 );
        --v38;
      }
      while ( v38 );
      sub_140001864(v51);
      sub_1400013CC(v51, 10);
      v40 = v51;
      v41 = v48;
      v42 = 4i64;
      do
      {
        v43 = v40;
        v44 = 4i64;
        do
        {
          LOBYTE(v9) = *(_BYTE *)v43;
          v43 += 4;
          *v41++ = v9;
          --v44;
        }
        while ( v44 );
        ++v40;
        --v42;
      }
      while ( v42 );
      v15 = (int *)&unk_140002498;
      v45 = v49-- == 1;
      v48 += 16;
    }
    while ( !v45 );
  }
  return v9;
}
// 14000157D: variable 'v3' is possibly undefined
// 1400016D3: variable 'v34' is possibly undefined
// 140002060: using guessed type _DWORD sbox[256];
// 1400024D8: using guessed type __int16 word_1400024D8;
// 140001460: using guessed type _DWORD var_B0[16];

//----- (00000001400017FC) ----------------------------------------------------
__int64 __fastcall sub_1400017FC(__int128 *a1, int a2)
{
  __int64 v2; // r8
  int v3; // edx
  __int64 result; // rax
  __int128 v5; // [rsp+0h] [rbp-28h]

  v2 = 0i64;
  v5 = *a1;
  v3 = a2 % 4;
  do
  {
    result = v3;
    *((_DWORD *)a1 + v2) = *((_DWORD *)&v5 + v3);
    v3 = (v3 + 1) % 4;
    ++v2;
  }
  while ( v2 < 4 );
  return result;
}

//----- (0000000140001864) ----------------------------------------------------
__int64 __fastcall sub_140001864(_OWORD *a1)
{
  _DWORD *v1; // rbx
  __int128 v2; // xmm1
  __int128 v3; // xmm0
  __int64 v4; // r11
  __int64 v5; // rcx
  __int64 result; // rax
  __int128 v7; // [rsp+20h] [rbp-48h] BYREF
  __int128 v8; // [rsp+30h] [rbp-38h] BYREF
  __int128 v9; // [rsp+40h] [rbp-28h] BYREF

  v1 = a1 + 2;
  v2 = a1[2];
  v9 = a1[3];
  v3 = a1[1];
  v8 = v2;
  v7 = v3;
  sub_1400017FC(&v7, 1);
  sub_1400017FC(&v8, 2);
  sub_1400017FC(&v9, 3);
  v5 = 4i64;
  do
  {
    *(v1 - 4) = *(_DWORD *)((char *)v1 + (_QWORD)&v7 - v4 - 32);
    *v1 = *(_DWORD *)((char *)v1 + (_QWORD)&v8 - v4 - 32);
    result = *(unsigned int *)((char *)v1 + (_QWORD)&v9 - v4 - 32);
    v1[4] = result;
    ++v1;
    --v5;
  }
  while ( v5 );
  return result;
}
// 1400018D6: variable 'v4' is possibly undefined

//----- (0000000140001960) ----------------------------------------------------
void __fastcall __noreturn kebugcheck(ULONG_PTR BugCheckParameter1)
{
  KeBugCheckEx(0xF7u, BugCheckParameter1, _security_cookie, BugCheckParameter3, 0i64);
}

//----- (00000001400019B0) ----------------------------------------------------
__int64 __fastcall sub_1400019B0(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  char v3; // dl

  result = *(_QWORD *)(a2 + 8);
  v3 = *(_BYTE *)(*(unsigned int *)(*(_QWORD *)(a2 + 16) + 8i64) + result + 3);
  if ( (v3 & 0xF) != 0 )
    return v3 & 0xF0;
  return result;
}

//----- (0000000140001A40) ----------------------------------------------------
__m128i *__fastcall sub_140001A40(__m128i *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __m128i *v3; // r11
  bool v4; // cf
  unsigned __int64 v5; // rdx
  unsigned __int64 k; // r9
  __int64 v7; // rax
  unsigned __int64 m; // r8
  __int8 v9; // al
  unsigned int v11; // ecx
  unsigned __int64 v12; // r9
  __m128i v13; // xmm0
  __m128i v14; // xmm1
  int v15; // eax
  int v16; // eax
  __m128i v17; // xmm1
  __m128i v18; // xmm1
  __m128i *v19; // rcx
  unsigned __int64 i; // r9
  __int64 v21; // rax
  unsigned __int64 j; // r8
  __int8 v23; // al
  __m128i *v24; // rax
  __int64 v25; // rcx
  unsigned __int64 v26; // r9
  __m128i v27; // xmm0
  __m128i v28; // xmm1
  int v29; // eax
  int v30; // eax
  __m128i v31; // xmm1
  __m128i v32; // xmm1
  void *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v3 = a1;
  v4 = a2 < (unsigned __int64)a1;
  v5 = a2 - (_QWORD)a1;
  if ( v4 )
  {
    v19 = (__m128i *)((char *)a1 + a3);
    if ( a3 >= 0x4F )
    {
      if ( v5 > 0xFFFFFFFFFFFFFFF0ui64 )
      {
        for ( ; ((unsigned __int8)v19 & 0xF) != 0; v19->m128i_i8[0] = v19->m128i_i8[v5] )
        {
          v19 = (__m128i *)((char *)v19 - 1);
          --a3;
        }
      }
      else
      {
        v24 = v19;
        v25 = (unsigned __int8)v19 & 0xF;
        if ( (_DWORD)v25 )
        {
          a3 -= (unsigned int)v25;
          v25 = -(__int64)(unsigned int)v25;
          v24[-1] = _mm_loadu_si128((__m128i *)((char *)v24 + v5 - 16));
        }
        v19 = (__m128i *)((char *)v24 + v25);
      }
      v26 = a3 >> 5;
      if ( a3 >> 5 <= 0x2000 || v5 > 0xFFFFFFFFFFFFFE00ui64 )
        goto LABEL_38;
      do
      {
        v29 = 4;
        do
        {
          v19 -= 8;
          _mm_prefetch(&v19->m128i_i8[v5], 0);
          _mm_prefetch(&v19[4].m128i_i8[v5], 0);
          --v29;
        }
        while ( v29 );
        v19 += 32;
        v30 = 8;
        do
        {
          v31 = _mm_loadu_si128((__m128i *)((char *)v19 + v5 - 32));
          _mm_stream_si128(v19 - 1, _mm_loadu_si128((__m128i *)((char *)v19 + v5 - 16)));
          _mm_stream_si128(v19 - 2, v31);
          v19 -= 4;
          v32 = _mm_loadu_si128((__m128i *)((char *)v19 + v5));
          _mm_stream_si128(v19 + 1, _mm_loadu_si128((__m128i *)((char *)v19 + v5 + 16)));
          _mm_stream_si128(v19, v32);
          --v30;
        }
        while ( v30 );
        a3 -= 512i64;
      }
      while ( a3 >= 0x200 );
      _InterlockedOr8((volatile signed __int8 *)&retaddr, 0);
      v26 = a3 >> 5;
      if ( a3 >> 5 )
      {
LABEL_38:
        a3 &= 0x1Fu;
        do
        {
          v27 = _mm_loadu_si128((__m128i *)((char *)v19 + v5 - 16));
          v28 = _mm_loadu_si128((__m128i *)((char *)v19 + v5 - 32));
          v19 -= 2;
          v19[1] = v27;
          *v19 = v28;
          --v26;
        }
        while ( v26 );
      }
    }
    for ( i = a3 >> 3; i; v19->m128i_i64[0] = v21 )
    {
      v21 = *(__int64 *)((char *)&v19->m128i_i64[-1] + v5);
      v19 = (__m128i *)((char *)v19 - 8);
      --i;
    }
    for ( j = a3 & 7; j; v19->m128i_i8[0] = v23 )
    {
      v23 = v19->m128i_i8[v5 - 1];
      v19 = (__m128i *)((char *)v19 - 1);
      --j;
    }
    return v3;
  }
  else
  {
    if ( a3 >= 0x4F )
    {
      if ( v5 < 0x10 )
      {
        for ( ; ((unsigned __int8)a1 & 0xF) != 0; a1 = (__m128i *)((char *)a1 + 1) )
        {
          --a3;
          a1->m128i_i8[0] = a1->m128i_i8[v5];
        }
      }
      else
      {
        v11 = -(int)a1 & 0xF;
        if ( v11 )
        {
          a3 -= v11;
          *v3 = _mm_loadu_si128((__m128i *)((char *)v3 + v5));
        }
        a1 = (__m128i *)((char *)v3 + v11);
      }
      v12 = a3 >> 5;
      if ( a3 >> 5 <= 0x2000 || v5 < 0x200 )
        goto LABEL_13;
      do
      {
        v15 = 4;
        do
        {
          _mm_prefetch(&a1->m128i_i8[v5], 0);
          _mm_prefetch(&a1[4].m128i_i8[v5], 0);
          a1 += 8;
          --v15;
        }
        while ( v15 );
        a1 -= 32;
        v16 = 8;
        do
        {
          v17 = _mm_loadu_si128((__m128i *)((char *)a1 + v5 + 16));
          _mm_stream_si128(a1, _mm_loadu_si128((__m128i *)((char *)a1 + v5)));
          _mm_stream_si128(a1 + 1, v17);
          a1 += 4;
          v18 = _mm_loadu_si128((__m128i *)((char *)a1 + v5 - 16));
          _mm_stream_si128(a1 - 2, _mm_loadu_si128((__m128i *)((char *)a1 + v5 - 32)));
          _mm_stream_si128(a1 - 1, v18);
          --v16;
        }
        while ( v16 );
        a3 -= 512i64;
      }
      while ( a3 >= 0x200 );
      _InterlockedOr8((volatile signed __int8 *)&retaddr, 0);
      v12 = a3 >> 5;
      if ( a3 >> 5 )
      {
LABEL_13:
        a3 &= 0x1Fu;
        do
        {
          v13 = _mm_loadu_si128((__m128i *)((char *)a1 + v5));
          v14 = _mm_loadu_si128((__m128i *)((char *)a1 + v5 + 16));
          a1 += 2;
          a1[-2] = v13;
          a1[-1] = v14;
          --v12;
        }
        while ( v12 );
      }
    }
    for ( k = a3 >> 3; k; a1[-1].m128i_i64[1] = v7 )
    {
      v7 = *(__int64 *)((char *)a1->m128i_i64 + v5);
      a1 = (__m128i *)((char *)a1 + 8);
      --k;
    }
    for ( m = a3 & 7; m; a1[-1].m128i_i8[15] = v9 )
    {
      v9 = a1->m128i_i8[v5];
      a1 = (__m128i *)((char *)a1 + 1);
      --m;
    }
    return v3;
  }
}

//----- (0000000140005000) ----------------------------------------------------
NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
  _security_init_cookie();
  return init1((__int64)DriverObject);
}

// nfuncs=23 queued=17 decompiled=17 lumina nreq=0 worse=0 better=0
// ALL OK, 17 function(s) have been successfully decompiled
