/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_55BDEDF09020();
// void free(void *ptr);
void sub_55BDEDF09036();
// int *__errno_location(void);
void sub_55BDEDF09046();
// char *strcpy(char *dest, const char *src);
void sub_55BDEDF09056();
// int puts(const char *s);
void sub_55BDEDF09066();
// ssize_t write(int fd, const void *buf, size_t n);
void sub_55BDEDF09076();
// int fclose(FILE *stream);
void sub_55BDEDF09086();
// size_t strlen(const char *s);
void sub_55BDEDF09096();
// void *mmap(void *addr, size_t len, int prot, int flags, int fd, __off_t offset);
void sub_55BDEDF090A6();
// uint16_t htons(uint16_t hostshort);
void sub_55BDEDF090B6();
// int printf(const char *format, ...);
void sub_55BDEDF090C6();
// void *memset(void *s, int c, size_t n);
void sub_55BDEDF090D6();
// int close(int fd);
void sub_55BDEDF090E6();
// ssize_t read(int fd, void *buf, size_t nbytes);
void sub_55BDEDF090F6();
// int memcmp(const void *s1, const void *s2, size_t n);
void sub_55BDEDF09106();
// char *fgets(char *s, int n, FILE *stream);
void sub_55BDEDF09116();
// int strcmp(const char *s1, const char *s2);
void sub_55BDEDF09126();
// struct hostent *gethostbyname(const char *name);
void sub_55BDEDF09136();
// int fprintf(FILE *stream, const char *format, ...);
void sub_55BDEDF09146();
// int feof(FILE *stream);
void sub_55BDEDF09156();
// void *memcpy(void *dest, const void *src, size_t n);
void sub_55BDEDF09166();
// void *malloc(size_t size);
void sub_55BDEDF09176();
// __int64 __isoc99_sscanf(_QWORD, const char *, ...); weak
void sub_55BDEDF09186();
// int munmap(void *addr, size_t len);
void sub_55BDEDF09196();
// void *memmove(void *dest, const void *src, size_t n);
void sub_55BDEDF091A6();
// FILE *fopen(const char *filename, const char *modes);
void sub_55BDEDF091B6();
// int atoi(const char *nptr);
void sub_55BDEDF091C6();
// int gethostname(char *name, size_t len);
void sub_55BDEDF091D6();
// void __noreturn exit(int status);
void sub_55BDEDF091E6();
// int connect(int fd, const struct sockaddr *addr, socklen_t len);
void sub_55BDEDF091F6();
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
void sub_55BDEDF09206();
// char *strerror(int errnum);
void sub_55BDEDF09216();
// int socket(int domain, int type, int protocol);
void sub_55BDEDF09226();
// int __fastcall _cxa_finalize(void *);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
void *sub_55BDEDF09270();
__int64 __fastcall sub_55BDEDF092A0(); // weak
void *sub_55BDEDF092E0();
__int64 __fastcall sub_55BDEDF09320(_QWORD, _QWORD, _QWORD); // weak
pages_pair_t *read_maps();
ssize_t __fastcall send_command(int a1, __int64 a2);
response_t *__fastcall read_socket(int socket); // idb
void __fastcall free_mem(void **a1);
ssize_t __fastcall main2(unsigned int socket); // idb
__int64 __fastcall main(int a1, char **a2, char **a3);
__int64 __fastcall sub_55BDEDF09A26(response_t *a1, pages_pair_t *a2); // idb
_QWORD *parse_file();
__int64 __fastcall next_node(map_entry_t *a1); // idb
_QWORD *__fastcall free_list(map_entry_t *a1); // idb
_BYTE *__fastcall read_maps_line(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _BYTE *a8);
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3);
void fini(void); // idb
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *funcs_555766F382A1)() = &sub_55BDEDF09320; // weak
__int64 (__fastcall *off_55BDEDF0CDF0)() = &sub_55BDEDF092E0; // weak
__int64 (*off_55BDEDF0D010)(void) = NULL; // weak
void *off_55BDEDF0D120 = &off_55BDEDF0D120; // idb
_UNKNOWN unk_55BDEDF0D128; // weak
FILE *stderr; // idb
char byte_55BDEDF0D148; // weak


//----- (000055BDEDF09000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    result = (__int64 (**)(void))_gmon_start__();
  return result;
}
// 55BDEDF0D268: using guessed type __int64 _gmon_start__(void);

//----- (000055BDEDF09020) ----------------------------------------------------
void sub_55BDEDF09020()
{
  off_55BDEDF0D010();
}
// 55BDEDF0D010: using guessed type __int64 (*off_55BDEDF0D010)(void);

//----- (000055BDEDF09036) ----------------------------------------------------
void sub_55BDEDF09036()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09046) ----------------------------------------------------
void sub_55BDEDF09046()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09056) ----------------------------------------------------
void sub_55BDEDF09056()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09066) ----------------------------------------------------
void sub_55BDEDF09066()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09076) ----------------------------------------------------
void sub_55BDEDF09076()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09086) ----------------------------------------------------
void sub_55BDEDF09086()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09096) ----------------------------------------------------
void sub_55BDEDF09096()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF090A6) ----------------------------------------------------
void sub_55BDEDF090A6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF090B6) ----------------------------------------------------
void sub_55BDEDF090B6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF090C6) ----------------------------------------------------
void sub_55BDEDF090C6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF090D6) ----------------------------------------------------
void sub_55BDEDF090D6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF090E6) ----------------------------------------------------
void sub_55BDEDF090E6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF090F6) ----------------------------------------------------
void sub_55BDEDF090F6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09106) ----------------------------------------------------
void sub_55BDEDF09106()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09116) ----------------------------------------------------
void sub_55BDEDF09116()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09126) ----------------------------------------------------
void sub_55BDEDF09126()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09136) ----------------------------------------------------
void sub_55BDEDF09136()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09146) ----------------------------------------------------
void sub_55BDEDF09146()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09156) ----------------------------------------------------
void sub_55BDEDF09156()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09166) ----------------------------------------------------
void sub_55BDEDF09166()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09176) ----------------------------------------------------
void sub_55BDEDF09176()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09186) ----------------------------------------------------
void sub_55BDEDF09186()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09196) ----------------------------------------------------
void sub_55BDEDF09196()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF091A6) ----------------------------------------------------
void sub_55BDEDF091A6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF091B6) ----------------------------------------------------
void sub_55BDEDF091B6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF091C6) ----------------------------------------------------
void sub_55BDEDF091C6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF091D6) ----------------------------------------------------
void sub_55BDEDF091D6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF091E6) ----------------------------------------------------
void sub_55BDEDF091E6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF091F6) ----------------------------------------------------
void sub_55BDEDF091F6()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09206) ----------------------------------------------------
void sub_55BDEDF09206()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09216) ----------------------------------------------------
void sub_55BDEDF09216()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09226) ----------------------------------------------------
void sub_55BDEDF09226()
{
  sub_55BDEDF09020();
}

//----- (000055BDEDF09240) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, (void (*)(void))init, fini, a3, &v5);
  __halt();
}
// 55BDEDF09246: positive sp value 8 has been found
// 55BDEDF0924D: variable 'v3' is possibly undefined

//----- (000055BDEDF09270) ----------------------------------------------------
void *sub_55BDEDF09270()
{
  return &unk_55BDEDF0D128;
}

//----- (000055BDEDF092A0) ----------------------------------------------------
__int64 sub_55BDEDF092A0()
{
  return 0LL;
}
// 55BDEDF092A0: using guessed type __int64 __fastcall sub_55BDEDF092A0();

//----- (000055BDEDF092E0) ----------------------------------------------------
void *sub_55BDEDF092E0()
{
  void *result; // rax

  if ( !byte_55BDEDF0D148 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_55BDEDF0D120);
    result = sub_55BDEDF09270();
    byte_55BDEDF0D148 = 1;
  }
  return result;
}
// 55BDEDF0D148: using guessed type char byte_55BDEDF0D148;

//----- (000055BDEDF09325) ----------------------------------------------------
pages_pair_t *read_maps()
{
  size_t v0; // rax
  pages_pair_t *v2; // [rsp+8h] [rbp-28h]
  map_entry_t *v3; // [rsp+10h] [rbp-20h]
  map_entry_t *list_head; // [rsp+18h] [rbp-18h]

  list_head = (map_entry_t *)parse_file();
  if ( !list_head )
  {
    fwrite("Couldn't parse /proc/self/maps!\n", 1uLL, 0x20uLL, stderr);
    exit(1);
  }
  while ( 1 )
  {
    v3 = (map_entry_t *)next_node(list_head);
    if ( !v3 )
    {
      free_list(list_head);
      fwrite("Couldn't find our memory mapping\n", 1uLL, 0x21uLL, stderr);
      exit(1);
    }
    if ( !strcmp(v3->permissions_str, "r-xp") )
    {
      v0 = strlen(v3->pathname);
      if ( !strcmp(&v3->device[v0 - 4], "secure-asset-manager") )
        break;
    }
  }
  v2 = (pages_pair_t *)malloc(0x10uLL);
  v2->start = v3->page_start;
  v2->end = v3->page_diff;
  free_list(list_head);
  return v2;
}

//----- (000055BDEDF0945D) ----------------------------------------------------
ssize_t __fastcall send_command(int a1, __int64 a2)
{
  __int16 buf; // [rsp+1Eh] [rbp-2h] BYREF

  buf = *(_QWORD *)(a2 + 8);
  write(a1, &buf, 2uLL);
  return write(a1, *(const void **)a2, *(_QWORD *)(a2 + 8));
}

//----- (000055BDEDF094BB) ----------------------------------------------------
response_t *__fastcall read_socket(int socket)
{
  void *response_len; // rax
  ssize_t bytes_read; // rax
  unsigned __int16 buf; // [rsp+16h] [rbp-Ah] BYREF
  response_t *v5; // [rsp+18h] [rbp-8h]

  read(socket, &buf, 2uLL);
  v5 = (response_t *)malloc(0x10uLL);
  v5->response_len = buf;
  response_len = malloc(v5->response_len);
  v5->response_data = (__int64)response_len;
  bytes_read = read(socket, (void *)v5->response_data, v5->response_len);
  if ( bytes_read != v5->response_len )
  {
    fwrite("ERROR: Failed to receive data!\n", 1uLL, 0x1FuLL, stderr);
    exit(1);
  }
  return v5;
}

//----- (000055BDEDF0957E) ----------------------------------------------------
void __fastcall free_mem(void **a1)
{
  free(*a1);
  free(a1);
}

//----- (000055BDEDF095A8) ----------------------------------------------------
ssize_t __fastcall main2(unsigned int socket)
{
  void *ptr; // [rsp+10h] [rbp-30h] BYREF
  size_t v3; // [rsp+18h] [rbp-28h]
  int challenge_response_value; // [rsp+2Ch] [rbp-14h]
  pages_pair_t *a2; // [rsp+30h] [rbp-10h]
  response_t *server_response; // [rsp+38h] [rbp-8h]

  printf("Connected to %s:%d\n", "secure-asset-manager-4235c8a4.challenges.bsidessf.net", 6112LL);
  server_response = read_socket(socket);
  printf("Server version: %s\n", (const char *)server_response->response_data);
  free_mem((void **)server_response);
  ptr = "secure-asset-manager client v1.00";
  v3 = 34LL;
  send_command(socket, (__int64)&ptr);
  server_response = read_socket(socket);
  printf("Received server challenge (%ld bytes), calculating response\n", server_response->response_len);
  a2 = read_maps();
  challenge_response_value = sub_55BDEDF09A26(server_response, a2);
  v3 = 4LL;
  ptr = malloc(4uLL);
  *(_BYTE *)ptr = challenge_response_value;
  *(_WORD *)((char *)ptr + 1) = *(_WORD *)((char *)&challenge_response_value + 1);
  *((_BYTE *)ptr + 3) = HIBYTE(challenge_response_value);
  free_mem((void **)server_response);
  puts("Sending challenge response");
  send_command(socket, (__int64)&ptr);
  free(ptr);
  server_response = read_socket(socket);
  if ( memcmp((const void *)server_response->response_data, "PASS", 4uLL) )
  {
    puts("Server challenge failed!");
    exit(0);
  }
  puts("Server challenge passed!");
  free_mem((void **)server_response);
  puts("Checking for updates...");
  ptr = "CHECK_UPDATES";
  v3 = 14LL;
  send_command(socket, (__int64)&ptr);
  server_response = read_socket(socket);
  if ( *(_BYTE *)server_response->response_data != 48 )
  {
    puts("The server says there's an update available! Please update your client before continuing");
    exit(0);
  }
  puts("No updates available!");
  free_mem((void **)server_response);
  ptr = malloc(0x406uLL);
  memcpy(ptr, "I_AM ", 5uLL);
  gethostname((char *)ptr + 5, 0x400uLL);
  puts("Checking in with hostname...");
  v3 = strlen((const char *)ptr) + 1;
  send_command(socket, (__int64)&ptr);
  server_response = read_socket(socket);
  if ( memcmp((const void *)server_response->response_data, "OK", 2uLL) )
  {
    puts("Something went wrong with checking in!");
    exit(0);
  }
  puts("Check-in successful! Thanks for using secure-asset-manager client v1.00!!");
  free_mem((void **)server_response);
  puts("Disconnecting...");
  ptr = "BYE";
  v3 = 4LL;
  return send_command(socket, (__int64)&ptr);
}

//----- (000055BDEDF098D8) ----------------------------------------------------
__int64 __fastcall main(int a1, char **a2, char **a3)
{
  struct sockaddr addr; // [rsp+10h] [rbp-20h] BYREF
  struct hostent *v5; // [rsp+20h] [rbp-10h]
  int socket; // [rsp+2Ch] [rbp-4h]

  socket = ::socket(2, 1, 0);
  if ( socket == -1 )
  {
    fwrite("Failed to create socket\n", 1uLL, 0x18uLL, stderr);
    exit(1);
  }
  v5 = gethostbyname("secure-asset-manager-4235c8a4.challenges.bsidessf.net");
  if ( !v5 )
  {
    fprintf(stderr, "Failed to resolve host %s\n", "secure-asset-manager-4235c8a4.challenges.bsidessf.net");
    exit(1);
  }
  *(_QWORD *)&addr.sa_family = 2LL;
  *(_QWORD *)&addr.sa_data[6] = 0LL;
  *(_WORD *)addr.sa_data = htons(0x17E0u);
  memmove(&addr.sa_data[2], *(const void **)v5->h_addr_list, v5->h_length);
  if ( connect(socket, &addr, 0x10u) )
  {
    fprintf(
      stderr,
      "Failed to connect to server %s:%d\n",
      "secure-asset-manager-4235c8a4.challenges.bsidessf.net",
      6112LL);
    exit(1);
  }
  main2(socket);
  close(socket);
  return 0LL;
}

//----- (000055BDEDF09A26) ----------------------------------------------------
__int64 __fastcall sub_55BDEDF09A26(response_t *a1, pages_pair_t *a2)
{
  unsigned int challenge_value; // [rsp+14h] [rbp-Ch]
  void *dest; // [rsp+18h] [rbp-8h]

  dest = mmap(0LL, a1->response_len, 7, 33, -1, 0LL);
  memcpy(dest, (const void *)a1->response_data, a1->response_len);
  challenge_value = ((__int64 (__fastcall *)(__int64, __int64))dest)(a2->start, a2->start + a2->end);
  memset(dest, 0, a1->response_len);
  munmap(dest, a1->response_len);
  return challenge_value;
}

//----- (000055BDEDF09AE1) ----------------------------------------------------
_QWORD *parse_file()
{
  int *v0; // rax
  char *v1; // rax
  _QWORD *list_head; // rax
  int inode_int; // eax
  char pathname[4096]; // [rsp+0h] [rbp-2130h] BYREF
  char inode[38]; // [rsp+1000h] [rbp-1130h] BYREF
  char device[10]; // [rsp+1026h] [rbp-110Ah] BYREF
  char offset[24]; // [rsp+1030h] [rbp-1100h] BYREF
  char permissions[8]; // [rsp+1048h] [rbp-10E8h] BYREF
  char page_end[32]; // [rsp+1050h] [rbp-10E0h] BYREF
  char page_start[32]; // [rsp+1070h] [rbp-10C0h] BYREF
  char maps_line[4208]; // [rsp+1090h] [rbp-10A0h] BYREF
  map_entry_t *v12; // [rsp+2100h] [rbp-30h]
  FILE *stream; // [rsp+2108h] [rbp-28h]
  _QWORD *v14; // [rsp+2110h] [rbp-20h]
  map_entry_t *v15; // [rsp+2118h] [rbp-18h]
  map_entry_t *v16; // [rsp+2120h] [rbp-10h]
  int v17; // [rsp+212Ch] [rbp-4h]

  v14 = malloc(0x10uLL);
  stream = fopen("/proc/self/maps", "r");
  if ( stream )
  {
    v17 = 0;
    v16 = 0LL;
    v15 = 0LL;
    while ( !feof(stream) )
    {
      fgets(maps_line, 4196, stream);
      v12 = (map_entry_t *)malloc(0x2A0uLL);
      read_maps_line(
        (__int64)maps_line,
        (__int64)page_start,
        (__int64)page_end,
        (__int64)permissions,
        (__int64)offset,
        (__int64)device,
        (__int64)inode,
        pathname);
      __isoc99_sscanf(page_start, "%lx", v12);
      __isoc99_sscanf(page_end, "%lx", &v12->page_end);
      v12->page_diff = v12->page_end - v12->page_start;
      strcpy(v12->permissions_str, permissions);
      v12->r = permissions[0] == 'r';
      v12->w = permissions[1] == 'w';
      v12->x = permissions[2] == 'x';
      v12->p = permissions[3] == 'p';
      __isoc99_sscanf(offset, "%lx", &v12->offset);
      strcpy(v12->device, device);
      inode_int = atoi(inode);
      v12->inode = inode_int;
      strcpy(v12->pathname, pathname);
      v12->next = 0LL;
      if ( !v17 )
      {
        v16 = v12;
        v12->next = 0LL;
        v15 = v16;
      }
      v15->next = (__int64)v12;
      v15 = v12;
      ++v17;
    }
    fclose(stream);
    *v14 = v16;
    v14[1] = v16;
    list_head = v14;
  }
  else
  {
    v0 = __errno_location();
    v1 = strerror(*v0);
    fprintf(stderr, "Cannot open /proc/self/maps, %s\n", v1);
    list_head = 0LL;
  }
  return list_head;
}
// 55BDEDF09180: using guessed type __int64 __isoc99_sscanf(_QWORD, const char *, ...);

//----- (000055BDEDF09DA9) ----------------------------------------------------
__int64 __fastcall next_node(map_entry_t *a1)
{
  __int64 v2; // [rsp+10h] [rbp-8h]

  if ( !a1->page_end )
    return 0LL;
  v2 = a1->page_end;
  a1->page_end = *(_QWORD *)(v2 + 664);
  return v2;
}

//----- (000055BDEDF09DEE) ----------------------------------------------------
_QWORD *__fastcall free_list(map_entry_t *a1)
{
  _QWORD *result; // rax
  _QWORD *v2; // [rsp+20h] [rbp-10h]
  void *ptr; // [rsp+28h] [rbp-8h]

  result = (_QWORD *)a1->page_start;
  if ( a1->page_start )
  {
    ptr = (void *)a1->page_start;
    result = *(_QWORD **)(a1->page_start + 664);
    v2 = result;
    while ( ptr )
    {
      free(ptr);
      result = v2;
      ptr = v2;
      if ( v2 )
      {
        result = (_QWORD *)v2[83];
        v2 = result;
      }
    }
  }
  return result;
}

//----- (000055BDEDF09E5B) ----------------------------------------------------
_BYTE *__fastcall read_maps_line(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, _BYTE *a8)
{
  _BYTE *result; // rax
  int v9; // [rsp+38h] [rbp-8h]
  int v10; // [rsp+38h] [rbp-8h]
  int v11; // [rsp+38h] [rbp-8h]
  int v12; // [rsp+38h] [rbp-8h]
  int v13; // [rsp+38h] [rbp-8h]
  int v14; // [rsp+38h] [rbp-8h]
  int i; // [rsp+3Ch] [rbp-4h]
  int v16; // [rsp+3Ch] [rbp-4h]

  for ( i = 0; *(_BYTE *)(i + a1) != 45; ++i )
    *(_BYTE *)(a2 + i) = *(_BYTE *)(i + a1);
  *(_BYTE *)(i + a2) = 0;
  v16 = i + 1;
  v9 = v16;
  while ( *(_BYTE *)(v16 + a1) != 9 && *(_BYTE *)(v16 + a1) != 32 )
  {
    *(_BYTE *)(a3 + v16 - v9) = *(_BYTE *)(v16 + a1);
    ++v16;
  }
  *(_BYTE *)(v16 - v9 + a3) = 0;
  while ( *(_BYTE *)(v16 + a1) == 9 || *(_BYTE *)(v16 + a1) == 32 )
    ++v16;
  v10 = v16;
  while ( *(_BYTE *)(v16 + a1) != 9 && *(_BYTE *)(v16 + a1) != 32 )
  {
    *(_BYTE *)(a4 + v16 - v10) = *(_BYTE *)(v16 + a1);
    ++v16;
  }
  *(_BYTE *)(v16 - v10 + a4) = 0;
  while ( *(_BYTE *)(v16 + a1) == 9 || *(_BYTE *)(v16 + a1) == 32 )
    ++v16;
  v11 = v16;
  while ( *(_BYTE *)(v16 + a1) != 9 && *(_BYTE *)(v16 + a1) != 32 )
  {
    *(_BYTE *)(a5 + v16 - v11) = *(_BYTE *)(v16 + a1);
    ++v16;
  }
  *(_BYTE *)(v16 - v11 + a5) = 0;
  while ( *(_BYTE *)(v16 + a1) == 9 || *(_BYTE *)(v16 + a1) == 32 )
    ++v16;
  v12 = v16;
  while ( *(_BYTE *)(v16 + a1) != 9 && *(_BYTE *)(v16 + a1) != 32 )
  {
    *(_BYTE *)(a6 + v16 - v12) = *(_BYTE *)(v16 + a1);
    ++v16;
  }
  *(_BYTE *)(v16 - v12 + a6) = 0;
  while ( *(_BYTE *)(v16 + a1) == 9 || *(_BYTE *)(v16 + a1) == 32 )
    ++v16;
  v13 = v16;
  while ( *(_BYTE *)(v16 + a1) != 9 && *(_BYTE *)(v16 + a1) != 32 )
  {
    *(_BYTE *)(a7 + v16 - v13) = *(_BYTE *)(v16 + a1);
    ++v16;
  }
  *(_BYTE *)(v16 - v13 + a7) = 0;
  *a8 = 0;
  while ( *(_BYTE *)(v16 + a1) == 9 || *(_BYTE *)(v16 + a1) == 32 )
    ++v16;
  v14 = v16;
  while ( *(_BYTE *)(v16 + a1) != 9 && *(_BYTE *)(v16 + a1) != 32 && *(_BYTE *)(v16 + a1) != 10 )
  {
    a8[v16 - v14] = *(_BYTE *)(v16 + a1);
    ++v16;
  }
  result = &a8[v16 - v14];
  *result = 0;
  return result;
}

//----- (000055BDEDF0A260) ----------------------------------------------------
void __fastcall init(unsigned int a1, __int64 a2, __int64 a3)
{
  signed __int64 v4; // rbp
  __int64 i; // rbx

  init_proc();
  v4 = &off_55BDEDF0CDF0 - &funcs_555766F382A1;
  if ( v4 )
  {
    for ( i = 0LL; i != v4; ++i )
      ((void (__fastcall *)(_QWORD, __int64, __int64))*(&funcs_555766F382A1 + i))(a1, a2, a3);
  }
}
// 55BDEDF09320: using guessed type __int64 __fastcall sub_55BDEDF09320(_QWORD, _QWORD, _QWORD);
// 55BDEDF0CDE8: using guessed type __int64 (__fastcall *funcs_555766F382A1)();
// 55BDEDF0CDF0: using guessed type __int64 (__fastcall *off_55BDEDF0CDF0)();

//----- (000055BDEDF0A2C4) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=121 queued=51 decompiled=51 lumina nreq=0 worse=0 better=0
// ALL OK, 51 function(s) have been successfully decompiled
